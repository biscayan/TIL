# 실용주의 접근법

## 중복의 해악
- 어떻게 중복이 생기는가?  
(1) 강요된 중복 : 개발자들은 다른 선택이 없다고 느낀다. 환경이 중복을 요구하는 것처럼 보인다.  
(2) 부주의한 중복 : 개발자들은 자신들이 정보를 중복하고 있다는 것을 깨닫지 못한다.  
(3) 참을성 없는 중복 : 중복이 쉬워 보이기 때문에 개발자들이 게을러져서 중복을 하게 된다.  
(4) 개발자간의 중복 : 한 팀에 있는 여러 사람들이 동일한 정보를 중복한다.  
### 강요된 중복
때떄로 우리는 중복을 강요당하는 것 같다.  
프로젝트 표준이 중복된 정보가 기록된 문서를 요구하기도 하고, 혹은 코드에 중복 정보가 생기는 문서를 요구하기도 한다.  
우리는 모두 중복을 피할 수 없을 듯한 상황에서 일해 보았다.  
하지만 많은 경우, 각각의 지식을 한 곳에 두면서 DRY원칙을 따르고, 동시에 우리의 삶을 더 편하게 만드는 길이 존재한다.  
#### 정보의 다양한 표현양식
약간의 창의력만 있으면 중복의 필요를 제거할 수 있다. 흔히 간단한 필터나 코드 생성기를 작성하는 것이 해답이다.  
스프트웨어가 빌드될 때마다 간단한 코드 생성기를 사용해 공동의 메타데이터 표현에서 여러 개의 언어에 걸쳐 있는 구조를 만들어낼 수 있다.  
#### 코드내의 문서화
나쁜 코드는 많은 주석을 필요로 한다.  
DRY원칙은 낮은 차원의 지식은 그것이 속하는 코드에 놔두고, 주석은 다른 높은 차원의 설명을 위해 아껴두라고 말한다.  
그렇지 않으면 지식을 중복하게 되며, 변경할 때마다 매번 코드와 주석 모두를 바꾸어야 한다.
#### 문서화와 코드 
보통 문서를 작성하고 나서 코드를 작성한다. 뭔가가 바뀌면, 문서를 수정하고 코드를 갱신한다.  
문서와 코드 모두는 동일 지식에 대한 표현이다. 문서 자체에서 테스트가 자동 생성되도록 하면 효율적이다.
### 참을성 없는 중복
모든 프로젝트는 시간의 압박을 받는다. 우리가 할 수 있는 최선이란 결국 지름길을 택하라는 압박말이다.  
만약 이런 유혹을 느낀다면 '돌아가는 길이 지름길이다' 라는 진부한 격언을 기억하라.  
지금 당장 몇 초를 절약할 수 있을지라도, 나중에는 몇 시간을 잃게 될런지 모른다.  
### 개발자간의 중복
발견하거나 다루기 가장 어려운 유형의 중복은 한 프로젝트에서 일하는 서로 다른 개발자 사이에서 발생한다.  
이런 중복은 수 년 동안 발견되지 않을 수 있으며, 이는 결국 유지보수 문제로 귀결될 것이다.  
높은 차원의 해법으로는 깨끗한 설계와 강력하고 기술적인 프로젝트 리더, 그리고 그 설계 내에서 책임의 분배가 제대로 이해되어야한다.  
우리가 느끼기에 최선책은 개발자간에 적극적이고 빈번한 소통을 장려하는 것이다.  
공통의 문제를 다루기 위하여 토론장을 만들어라.  
코드 리뷰 시 다른 사람의 소스코드와 문서를 읽도록 하라. 다른 사람의 것을 기웃거리는게 아니라 거기서 배우는 것이다.

## 직교성
### 직교성이란
기하학에서 직교성이란 두 직선이 직각으로 만나는 것을 말한다. 두 개의 선은 독립적이다.  
컴퓨팅에서도 직교는 독립성과 관련이 있는데,  
하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다.  
잘 설계된 시스템에서는 데이터베이스 코드가 사용자 인터페이스에 대해 직교할 것이다.  
데이터베이스에 영향을 주지 않으면서 인터페이스를 바꿀 수 있고, 또한 인터페이스를 바꾸지 않으면서 데이터베이스를 교환할 수 있다.  
### 직교성의 장점
우리는 자족적인 컴포넌트를 설계하기를 원한다. 컴포넌트들이 각각 격리되어 있으면 어느 하나를 바꿀 때 나머지 것들을 걱정하지 않아도 된다.  
### 생산성 향상
변화가 국소화되서 개발 시간과 테스트 시간이 줄어든다.  
컴포넌트들이 명확하고 잘 정의된 책임이 할당되어 있다면, 새로운 방식으로 컴포넌트들을 결합할 수도 있다.  
시스템이 더 느슨하게 결합되어 있을수록 재설정하고 리엔지니어링하기 휩다.  
### 리스크 감소
감염된 코드는 격리가 된다. 그리고 그 부분만 도려내고 새롭게 건강한 놈으로 이식해 넣기도 쉽다.  
또한 시스템이 잘 깨어지지 않는다. 어떤 부분을 골라서 약간 바꾼다 하더라도 거기서 생기는 문제점들은 그 부분에만 한정될 것이다.  
### 설계
시스템은 협력하는 모듈들의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다.  
때로는 이런 컴포넌트들이 레이어로 조직되기도 하는데, 각 레이어는 하나의 추상화 층을 이루게 된다.  
각 레이어는 자기 밑에 있는 레이어들이 제공하는 추상화만을 사용하기 때문에, 
코드에 영향을 끼치지 않으면서 아래에 있는 다른 구현들을 바꾸는 높은 유연성을 얻을 수 있다.  
레이어를 두는 것은 또한 모듈 간에 종속성이 빨리 늘어나는 위험을 감소시킨다.  
### 코딩
1. 코드의 결합도를 줄여라.  
2. 전역데이터를 피하라.  
3. 유사한 함수를 피하라.  
### 직교적으로 살아가기
직교성은 DRY 원리와도 밀접한 관계가 있다. 
DRY원리는 시스템 내부의 중복을 최소화시키고, 직교성은 시스템 컴포넌트 간의 상호의존도를 줄인다.  
DRY원리로 무장하고, 직교성 원리를 충실히한다면, 개발하고 있는 시스템이 더 유연하고, 이해하기 쉽고 또한 디버그, 테스트, 유지도 쉬워질 것이다.  

## 가역성
결정이 돌에 새겨지는 것이라 가정하고, 발생할지도 모를 우연한 사건들에 대해 준비하지 않는 데에서 실수가 나온다.  
결정이 돌에 새겨진 것이 아니라 해변가의 모래 위에 쓰인 글씨라 생각해 보자.  
언제든지 큰 파도가 글씨를 지워버릴 수 있다.  
### 유연한 아키텍처
누구도 미래에 대해서는 알 수 없으며, 우리라고 예외는 아니다.  
우리의 코드가 로큰롤을 할 수 있게 하라.  
락을 할 수도 있고 필요한 경우에는 롤을 할 수도 있게 하는 것이다.  

## 예광탄
익숙하지 않은 알고리즘, 기술, 언어, 라이브러리들을 사용해야 할지도 모르므로, 우리는 수많은 미지의 것과 맞닥뜨리게 될 것이다.  
모든 불확실한 점을 잡아매고, 환경 조건을 제약하고, 모든 요구사항을 일일이 항목으로 만들어서 몇 상자나 되는 명세서를 만들라는 것이 전형적인 반응이다.  
하지만 실용주의 프로그래머는 예광탕 사용을 선호한다.  
## 어둠 속에서 빛을 내는 코드 
코딩에서도 예광탄과 동일한 효과를 얻으려면, 우리를 요구사항으로부터 최종 시스템의 일부 측면에까지 빨리, 눈에 보이게, 반복적으로 도달하게 해줄 무언가를 찾아야 한다.  
예광탄 코드는 나중에 버리려고 만드는 것이 아니다.  
예광탄 코드에고 상용 코드와 마찬가지로 모든 에러 검사, 구조화, 문서화, 자기 검사가 포함된다.  
단지 예광탄 코드에는 아직 완전한 기능이 들어 있지 않을 뿐이다.  
그렇게 해서 일단 목표물을 맞춘다면 기능을 추가하는 일은 쉽다.  
### 예광탄 코드 접근 방법의 장점
- 사용자들은 뭔가 작동되는 것을 일찍부터 보게 된다.  
- 개발자들은 들어가서 일할 수 있는 구조를 얻는다.  
- 통합 작업을 수행할 기반이 생긴다.  
- 보여줄 것이 생긴다.  
- 진전 상황에 대해 더 정확하게 감을 잡을 수 있다.  
## 예광탄이 언제나 목표물을 맞추는 것은 아니다.  
예광탕 코드 기법은 일이 어떻게 될지 100% 확신할 수 없는 상황에서 사용된다.  
그러므로 처음 몇 번 시도 때 목표에 맞지 않더라도 놀랄 필요가 없다.  
지금 있는 것을 목표물에 가까이 가져가려면 어떻게 바꾸어야 할지 생각해내고, 가벼운 개발 방법론을 선택했다는 사실에 감사하라.  
코드의 크기가 작으면 관성 역시 약하므로 빠르고 쉽게 바꿀 수 있다.  
## 예광탄 코드 대 프로토타이핑
프로토타입은 최종 시스템의 어떤 특정한 측면을 탐사해 보는 것이 목표다.  
진짜 프로토타입 방식을 따른다면, 어떤 개념을 구현해 보려고 시도할 때 대충 끼워 맞춘 것들을 모두 버린 다음, 실험 과정에서 얻은 교훈을 바탕으로 다시 코드를 만들게 된다.  
일단 결정은 내린 후라면, 다시 처음부터 시작해서 현실 세계와 상호작용하는 최종 환경에서 알고리즘을 코드로 작성한다.  
예광탄코드와 프로토타입의 차이점은 매우 중요하다.  
프로토타입은 나중에 버릴 수 있는 코드를 만드는 것이고, 예광탄코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격의 일부를 이룬다.  
프로토타입은 예광탄이 하나라도 발사되기 전에 먼저 일어나는 정찰과 정보 수집 정도로 생각하면 되겠다.  

## 프르토타입과 포스트잇
프로토타입은 반드시 코드로 작성해야 한다고 생각하는 사람도 있지만, 꼭 그럴 필요는 없다.  
포스트잇은 작업흐름과 어플리케이션 로직과 같은 동적인 것들을 프로토타이핑해 볼 수 있는 훌륭한 도구다.  
### 프로토타입의 대상
프로토타입의 대상은 위험을 수반하는 모든 것이다. 또한 이전에 해본 적이 없는 것, 최종 시스템에 매우 중요한 것 등이 프로토타입의 대상이 된다.  
증명되지 않았거나, 실험적이거나, 의심이 가는 것, 심적으로 편하지 않은 것 모두가 프로토타이핑의 대상이 될 수 있다.  
프로토타이핑은 학습 경험이며, 프로토타입의 가치는 생성괸 코드에 있는 것이 아니라 이를 통해 배우게 되는 교훈에 있다. 이것이 진정한 핵심이다.  
### 프로토타입을 어떻게 사용할 것인가?