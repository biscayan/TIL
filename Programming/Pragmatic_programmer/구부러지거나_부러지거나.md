# 구부러지거나 부러지거나 
현대의 미친 듯이 빠른 변화에 맞추기 위해서는 가능한 느슨하고 유연한 코드를 작성하기 위해 노력해야 한다. 그렇지 않으면 코드는 금세 낡고 수정하기 어려워져 기억 저편으로 사라져 버릴 것이기 때문이다.  
이 장에서는 되돌릴 수 있는 의사 결정을 내릴 수 있는 구체적인 방법에 대해 설명한다. 이를 잘 활용하면 작성하고 있는 코드가 불확실한 세상에 닥쳐도 유연성과 적응성일 읋지 않을 것이다.  

## 결합도 줄이기와 디미터 법칙
코드를 모듈로 구성하고, 이들 간의 상호작용을 제한하라. 그러면 한 모듈이 변경되거나 교체된다 하더라도 다른 모듈들은 변경 없이 수행될 수 있을 것이다.  
### 결합도 줄이기
어떤 객체에게 특정 서비스를 요청했을 때 이 요청을 바로 처리해 주기 바라지, 제 3의 객체를 넘겨받아 이미 요청한 서비스를 가지고 다시 일을 하고 싶지 않을 것이다.  
코드 간 결합이 증가하면, 시스템 어딘가의 무관한 변화가 다른 코드에 영향을 미칠 수 있는 위험이 커지게 된다.  
불필요한 의존이 많은 시스템은 유지보수하기 어렵고, 이로 인해 많은 비용이 발생하며 시스템 자체가 매우 불안정한 경향이 있다.  
따라서 우리는 의존도를 최소화하기 위해 디미터 법칙을 사용하여 메소드, 함수를 설계해야 한다.  
### 디미터 함수 법칙 
디미터 함수 법칙은 프로그램에서 모듈간 결합도를 최소화하려 한다. 이 법칙은 한 객체가 제공하는 메소드에 접근하기 위해 또 다른 객체들을 통하는 것을 허용하지 않는다.  
'부끄럼 타는' 코드를 작성해서 디미터 법칙을 만족시킨다면 우리의 목적을 이룰 수 있다. 
### 확실히 차이를 낳는가?
응답집합이 큰 클래스는 작은 클래스보다 에러를 발생시키기 쉽다고 한다. 이때 응답집합은 클래스의 메소드가 직접 호출하는 함수의 수를 의미한다.  
디미터 법칙을 따르면 함수를 호출하는 클래스의 응답집합 크기를 줄일 수 있기 때문에 좀 더 에러가 적은 클래스들을 만들 수 있다.  
디미터 법칙은 코드를 더 적응성 있고 강하게 만들어 주지만, 요청을 전달하는 역할만을 하는 간단한 위임 메소드를 상당수 만들어내게 된다.  
이러한 위임 메소드는 성능 저하와 메모리 과부하와 같은 문제를 야기할 수 있으며, 이러한 문제는 어떤 종류의 어플리케이션에서는 심각할 수 있고, 심지어는 절대 금해야 하는 것일 수도 있다.  
따라서 여느 기술과 마찬가지로 디미터 법칙 역시 만들려고 하는 어플리케이션에 맞게 장점과 단점을 잘 고려하여 사용해야 한다.  

## 메타프로그래밍
### 동적 설정
우리는 알고리즘, 데이터베이스, 인터페이스 등을 포함하여 시스템을 되도록 설정가능하게 만들기 바란다. 그러기 위해서는 이런 아이템들을 통합하거나 엔지니어링하지 말고 설정 옵션으로 구현해야 한다.  
메타데이터를 이용하여 반환 매개 변수, 사용자 선호사항, 설치 디렉토리와 같은 어플리케이션 설정 옵션을 기술하라.  
메타데이터는 어플리케이션을 기술하는 모든 데이터이다. 어플리케이션이 어떻게 실행되어야 하고, 어떤 자원을 이용해야 하는지 등을 기술한다면 메타데이터라 할 수 있겠다.  

## 시간적 결합
시간에는 우리에게 의미 있는 두 가지 측면이 있다. 첫째는 동시성이고 두번째는 순서이다.  
보통은 프로그래밍할 때 두 측면 가운데 어느 것도 특별히 신경 쓰지 않는다. 자리에 앉아 아키텍쳐를 설계하거나 프로그램을 짜기 시작할 때는 보통 직선적 사고를 하기 마련이다.  
이것을 한 다음 저것을 하고.. 하지만 이런 사고방식은 시간적 결합을 만들게 된다. 메소드 A는 반드시 메소드 B보다 먼저 호출되어야 하고, 보고서는 한 번에 오직 하나만 실행될 수 있다. 이러한 접근 방법은 그다지 유연하지 않고, 현실적이지도 않다.  
우리는 동시성을 허용할 필요가 있고, 시간이나 순서에 따른 의존성의 결합을 끊을 방법을 생각할 필요가 있다. 그렇게 해야 유연성도 얻을 수 있고, 작업흐름 분석, 아키텍처, 설계, 배치와 같은 개발의 여러 측면에서 시간과 관련된 모든 의존성도 줄일 수 있다.  
### 작업흐름
많은 프로젝트에서 요구사항 분석의 일부로서 사용자들의 작업흐름을 모델화하고 분석하는 작업이 필요하다. 우리가 원하는 것은 동시에 일어나도 되는 것은 어떤 것이고, 엄격한 순서에 따라 일어나야 하는 것은 어떤 것인지 찾아내는 것이다.  
UML 활동 다이어그램 같이 표기법을 사용해서 사용자들이 기술해 준 작업흐름을 기록하는 것이 하나의 방법이다.  
활동 다이어그램을 사용하면 동시에 수행될 수 있지만 아직 그렇지 않은 활동들을 찾아내서 병렬성을 극대화할 수 있다.  
### 동시성을 고려한 설계
직선형 코드에서는 엄밀하지 않은 프로그래밍으로 이끌리는 전제들을 남발하기 쉽다. 하지만 동시성을 염두에 둔다면 여러 가지 일들을 더 주의 깊게 생각하게 될 수밖에 없다.  
이제는 여러 일들이 동시에 일어날 수 있기 때문에 전에는 보지 못 보던 시간에 관련된 의존성들이 보이기 시작한다.  
### 배치
동시성 요소가 포함된 아키텍처를 설계한 다음에는 수많은 동시적 서비스들을 다루는 것에 대해 생각하기도 더 쉬워진다. 동시성 모델이 도처에 스며들게 되는 것이다.  
이제는 어플리케이션을 어떻게 배치할지를 결정하는 문제에 대해서도 유연하게 대응할 수 있다.